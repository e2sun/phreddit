{"ast":null,"code":"function SortPosts({\n  array,\n  type,\n  comments\n}) {\n  const eqId = (a, b) => a.toString() === b.toString();\n\n  // recurse through replies\n  function getLatestTimestampForComment(comment) {\n    let maxTs = new Date(comment.commentedDate).getTime();\n    (comment.commentIDs || []).forEach(childId => {\n      const child = comments.find(c => eqId(c._id, childId)); //Use mongoID \n      if (child) {\n        const childTs = getLatestTimestampForComment(child);\n        if (childTs > maxTs) maxTs = childTs;\n      }\n    });\n    return maxTs;\n  }\n  function getLatestCommentTimestamp(post) {\n    let maxTs = new Date(post.postedDate).getTime(); //Posts with no comments fall back on creation time\n    (post.commentIDs || []).forEach(rootId => {\n      const root = comments.find(c => eqId(c._id, rootId));\n      if (root) {\n        const ts = getLatestTimestampForComment(root);\n        if (ts > maxTs) maxTs = ts;\n      }\n    });\n    return maxTs;\n  }\n  const cloned = [...array];\n  if (type === \"active\") {\n    return cloned.sort((a, b) => {\n      const aTs = getLatestCommentTimestamp(a);\n      const bTs = getLatestCommentTimestamp(b);\n      // tie breaker\n      if (aTs === bTs) {\n        return new Date(b.postedDate) - new Date(a.postedDate);\n      }\n      return bTs - aTs;\n    });\n  }\n  if (type === \"oldest\") {\n    return cloned.sort((a, b) => new Date(a.postedDate) - new Date(b.postedDate));\n  }\n  return cloned.sort((a, b) => new Date(b.postedDate) - new Date(a.postedDate));\n}\n_c = SortPosts;\nexport default SortPosts;\nvar _c;\n$RefreshReg$(_c, \"SortPosts\");","map":{"version":3,"names":["SortPosts","array","type","comments","eqId","a","b","toString","getLatestTimestampForComment","comment","maxTs","Date","commentedDate","getTime","commentIDs","forEach","childId","child","find","c","_id","childTs","getLatestCommentTimestamp","post","postedDate","rootId","root","ts","cloned","sort","aTs","bTs","_c","$RefreshReg$"],"sources":["/Users/evelynsun/Desktop/phreddit/Client/src/components/SortPosts.jsx"],"sourcesContent":["\nfunction SortPosts({ array, type, comments }) {\n  const eqId = (a, b) => a.toString() === b.toString();\n\n  // recurse through replies\n  function getLatestTimestampForComment(comment) {\n    let maxTs = new Date(comment.commentedDate).getTime();\n    (comment.commentIDs || []).forEach(childId => {\n      const child = comments.find(c => eqId(c._id, childId)); //Use mongoID \n      if (child) {\n        const childTs = getLatestTimestampForComment(child);\n        if (childTs > maxTs) maxTs = childTs;\n      }\n    });\n    return maxTs;\n  }\n\n \n  function getLatestCommentTimestamp(post) {\n    let maxTs = new Date(post.postedDate).getTime();  //Posts with no comments fall back on creation time\n    (post.commentIDs || []).forEach(rootId => {\n      const root = comments.find(c => eqId(c._id, rootId));\n      if (root) {\n        const ts = getLatestTimestampForComment(root);\n        if (ts > maxTs) maxTs = ts;\n      }\n    });\n    return maxTs;\n  }\n\n  const cloned = [...array];\n\n  if (type === \"active\") {\n    return cloned.sort((a, b) => {\n      const aTs = getLatestCommentTimestamp(a);\n      const bTs = getLatestCommentTimestamp(b);\n      // tie breaker\n      if (aTs === bTs) {\n        return new Date(b.postedDate) - new Date(a.postedDate);\n      }\n      return bTs - aTs;\n    });\n  }\n\n  if (type === \"oldest\") {\n    return cloned.sort(\n      (a, b) => new Date(a.postedDate) - new Date(b.postedDate)\n    );\n  }\n\n  return cloned.sort(\n    (a, b) => new Date(b.postedDate) - new Date(a.postedDate)\n  );\n}\n\nexport default SortPosts;"],"mappings":"AACA,SAASA,SAASA,CAAC;EAAEC,KAAK;EAAEC,IAAI;EAAEC;AAAS,CAAC,EAAE;EAC5C,MAAMC,IAAI,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACE,QAAQ,CAAC,CAAC,KAAKD,CAAC,CAACC,QAAQ,CAAC,CAAC;;EAEpD;EACA,SAASC,4BAA4BA,CAACC,OAAO,EAAE;IAC7C,IAAIC,KAAK,GAAG,IAAIC,IAAI,CAACF,OAAO,CAACG,aAAa,CAAC,CAACC,OAAO,CAAC,CAAC;IACrD,CAACJ,OAAO,CAACK,UAAU,IAAI,EAAE,EAAEC,OAAO,CAACC,OAAO,IAAI;MAC5C,MAAMC,KAAK,GAAGd,QAAQ,CAACe,IAAI,CAACC,CAAC,IAAIf,IAAI,CAACe,CAAC,CAACC,GAAG,EAAEJ,OAAO,CAAC,CAAC,CAAC,CAAC;MACxD,IAAIC,KAAK,EAAE;QACT,MAAMI,OAAO,GAAGb,4BAA4B,CAACS,KAAK,CAAC;QACnD,IAAII,OAAO,GAAGX,KAAK,EAAEA,KAAK,GAAGW,OAAO;MACtC;IACF,CAAC,CAAC;IACF,OAAOX,KAAK;EACd;EAGA,SAASY,yBAAyBA,CAACC,IAAI,EAAE;IACvC,IAAIb,KAAK,GAAG,IAAIC,IAAI,CAACY,IAAI,CAACC,UAAU,CAAC,CAACX,OAAO,CAAC,CAAC,CAAC,CAAE;IAClD,CAACU,IAAI,CAACT,UAAU,IAAI,EAAE,EAAEC,OAAO,CAACU,MAAM,IAAI;MACxC,MAAMC,IAAI,GAAGvB,QAAQ,CAACe,IAAI,CAACC,CAAC,IAAIf,IAAI,CAACe,CAAC,CAACC,GAAG,EAAEK,MAAM,CAAC,CAAC;MACpD,IAAIC,IAAI,EAAE;QACR,MAAMC,EAAE,GAAGnB,4BAA4B,CAACkB,IAAI,CAAC;QAC7C,IAAIC,EAAE,GAAGjB,KAAK,EAAEA,KAAK,GAAGiB,EAAE;MAC5B;IACF,CAAC,CAAC;IACF,OAAOjB,KAAK;EACd;EAEA,MAAMkB,MAAM,GAAG,CAAC,GAAG3B,KAAK,CAAC;EAEzB,IAAIC,IAAI,KAAK,QAAQ,EAAE;IACrB,OAAO0B,MAAM,CAACC,IAAI,CAAC,CAACxB,CAAC,EAAEC,CAAC,KAAK;MAC3B,MAAMwB,GAAG,GAAGR,yBAAyB,CAACjB,CAAC,CAAC;MACxC,MAAM0B,GAAG,GAAGT,yBAAyB,CAAChB,CAAC,CAAC;MACxC;MACA,IAAIwB,GAAG,KAAKC,GAAG,EAAE;QACf,OAAO,IAAIpB,IAAI,CAACL,CAAC,CAACkB,UAAU,CAAC,GAAG,IAAIb,IAAI,CAACN,CAAC,CAACmB,UAAU,CAAC;MACxD;MACA,OAAOO,GAAG,GAAGD,GAAG;IAClB,CAAC,CAAC;EACJ;EAEA,IAAI5B,IAAI,KAAK,QAAQ,EAAE;IACrB,OAAO0B,MAAM,CAACC,IAAI,CAChB,CAACxB,CAAC,EAAEC,CAAC,KAAK,IAAIK,IAAI,CAACN,CAAC,CAACmB,UAAU,CAAC,GAAG,IAAIb,IAAI,CAACL,CAAC,CAACkB,UAAU,CAC1D,CAAC;EACH;EAEA,OAAOI,MAAM,CAACC,IAAI,CAChB,CAACxB,CAAC,EAAEC,CAAC,KAAK,IAAIK,IAAI,CAACL,CAAC,CAACkB,UAAU,CAAC,GAAG,IAAIb,IAAI,CAACN,CAAC,CAACmB,UAAU,CAC1D,CAAC;AACH;AAACQ,EAAA,GApDQhC,SAAS;AAsDlB,eAAeA,SAAS;AAAC,IAAAgC,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}